<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>AES题型 | Crypto</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>AES题型</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-01-16T18:02:45.000Z" id="date"> 2025-01-17</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-01-16T18:02:58.067Z" id="updated"> 2025-01-17</time></div></span></div></div><hr><div id="post-content"><h3 id="1-单独涉及ECB模式"><a href="#1-单独涉及ECB模式" class="headerlink" title="1.单独涉及ECB模式"></a>1.单独涉及ECB模式</h3><p>最常见的是RSA中套了一个简单的AES_ECB加密，就是AES加密flag，只要先将用RSA加密的key解出，就能解的flag</p>
<h3 id="2-单独涉及CBC模式"><a href="#2-单独涉及CBC模式" class="headerlink" title="2.单独涉及CBC模式"></a>2.单独涉及CBC模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from Crypto.Cipher import AES<br>import os<br>from hashlib import sha256<br>import socketserver<br>import signal<br>import string<br>import random<br><br>table = string.ascii_letters + string.digits<br>BANNER = br&#x27;&#x27;&#x27;<br> .d8888b.  d8b                   888                            888             <br>d88P  Y88b Y8P                   888                            888             <br>888    888                       888                            888             <br>888        888 888  888  .d88b.  888888        .d8888b  8888b.  888888          <br>888        888 888  888 d8P  Y8b 888          d88P&quot;        &quot;88b 888             <br>888    888 888 Y88  88P 88888888 888          888      .d888888 888             <br>Y88b  d88P 888  Y8bd8P  Y8b.     Y88b.        Y88b.    888  888 Y88b.           <br> &quot;Y8888P&quot;  888   Y88P    &quot;Y8888   &quot;Y888        &quot;Y8888P &quot;Y888888  &quot;Y888          <br>                                                                                <br>                                                                                <br>                                                                                <br> .d888                        8888888b.          d8b                            <br>d88P&quot;                         888   Y88b         Y8P                            <br>888                           888    888                                        <br>888888  .d88b.  888d888       888   d88P 888d888 888 88888b.   .d8888b  .d88b.  <br>888    d88&quot;&quot;88b 888P&quot;         8888888P&quot;  888P&quot;   888 888 &quot;88b d88P&quot;    d8P  Y8b <br>888    888  888 888           888        888     888 888  888 888      88888888 <br>888    Y88..88P 888           888        888     888 888  888 Y88b.    Y8b.     <br>888     &quot;Y88P&quot;  888           888        888     888 888  888  &quot;Y8888P  &quot;Y8888<br>&#x27;&#x27;&#x27;<br><br>guard_menu = br&#x27;&#x27;&#x27;<br>1.Tell the guard my name<br>2.Go away<br>&#x27;&#x27;&#x27;<br><br>cat_menu = br&#x27;&#x27;&#x27;1.getpermission<br>2.getmessage<br>3.say Goodbye<br>&#x27;&#x27;&#x27;<br><br><br>def Pad(msg):<br>    return msg + os.urandom((16 - len(msg) % 16) % 16)<br><br><br>class Task(socketserver.BaseRequestHandler):<br>    def _recvall(self):<br>        BUFF_SIZE = 2048<br>        data = b&#x27;&#x27;<br>        while True:<br>            part = self.request.recv(BUFF_SIZE)<br>            data += part<br>            if len(part) &lt; BUFF_SIZE:<br>                break<br>        return data.strip()<br><br>    def send(self, msg, newline=True):<br>        try:<br>            if newline:<br>                msg += b&#x27;\n&#x27;<br>            self.request.sendall(msg)<br>        except:<br>            pass<br><br>    def recv(self, prompt=b&#x27;[-] &#x27;):<br>        self.send(prompt, newline=False)<br>        return self._recvall()<br><br>    def proof_of_work(self):<br>        proof = (&#x27;&#x27;.join([random.choice(table) for _ in range(12)])).encode()<br>        sha = sha256(proof).hexdigest().encode()<br>        self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha)<br>        XXXX = self.recv(prompt=b&#x27;[+] Give Me XXXX :&#x27;)<br>        if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha:<br>            return False<br>        return True<br><br>    def register(self):<br>        self.send(b&#x27;&#x27;)<br>        username = self.recv()<br>        return username<br><br>    def getpermission(self, name, iv, key):<br>        aes = AES.new(key, AES.MODE_CBC, iv)<br>        plain = Pad(name)+b&quot;a_cat_permission&quot;<br>        return aes.encrypt(plain)<br><br>    def getmessage(self, iv, key, permission):<br>        aes = AES.new(key, AES.MODE_CBC, iv)<br>        return aes.decrypt(permission)<br><br>    def handle(self):<br>        signal.alarm(50)<br>        if not self.proof_of_work():<br>            return<br>        self.send(BANNER, newline=False)<br>        self.key = os.urandom(16)<br>        self.iv = os.urandom(16)<br>        self.send(b&quot;I&#x27;m the guard, responsible for protecting the prince&#x27;s safety.&quot;)<br>        self.send(b&quot;You shall not pass, unless you have the permission of the prince.&quot;)<br>        self.send(b&quot;You have two choices now. Tell me who you are or leave now!&quot;)<br>        self.send(guard_menu, newline=False)<br>        option = self.recv()<br>        if option == b&#x27;1&#x27;:<br>            try:<br>                self.name = self.register()<br>                self.send(b&quot;Hello &quot; + self.name)<br>                self.send(b&quot;Nice to meet you. But I can&#x27;t let you pass. I can give you a cat. She will play with you&quot;)<br>                self.send(b&#x27;Miao~ &#x27; + self.iv)<br>                for i in range(3):<br>                    self.send(b&quot;I&#x27;m a magic cat. What can I help you&quot;)<br>                    self.send(cat_menu, newline=False)<br>                    op = self.recv()<br>                    if op == b&#x27;1&#x27;:<br>                        self.send(b&quot;Looks like you want permission. Here you are~&quot;)<br>                        permission = self.getpermission(self.name, self.iv, self.key)<br>                        self.send(b&quot;Permission:&quot; + permission)<br>                    elif op == b&#x27;2&#x27;:<br>                        self.send(b&quot;Looks like you want to know something. Give me your permission:&quot;)<br>                        permission = self.recv()<br>                        self.send(b&quot;Miao~ &quot;)<br>                        iv = self.recv()<br>                        plain = self.getmessage(iv, self.key, permission)<br>                        self.send(b&quot;The message is &quot; + plain)<br>                    elif op == b&#x27;3&#x27;:<br>                        self.send(b&quot;I&#x27;m leaving. Bye~&quot;)<br>                        break<br>                self.send(b&quot;Oh, you&#x27;re here again. Let me check your permission.&quot;)<br>                self.send(b&quot;Give me your permission:&quot;)<br>                cipher = self.recv()<br>                self.send(b&quot;What&#x27;s the cat tell you?&quot;)<br>                iv = self.recv()<br>                plain = self.getmessage(iv, self.key, cipher)<br>                prs, uid = plain[16:],plain[:16]<br>                if prs != b&#x27;Princepermission&#x27; or uid != self.name:<br>                    self.send(b&quot;You don&#x27;t have the Prince Permission. Go away!&quot;)<br>                    return<br>                else:<br>                    self.send(b&quot;Unbelievable! How did you get it!&quot;)<br>                    self.send(b&quot;The prince asked me to tell you this:&quot;)<br>                    f = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;)<br>                    flag = f.read()<br>                    f.close()<br>                    self.send(flag)<br>            except:<br>                self.request.close()<br>        if option == b&#x27;2&#x27;:<br>            self.send(b&quot;Stay away from here!&quot;)<br>        self.request.close()<br><br><br>class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):<br>    pass<br><br><br>class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):<br>    pass<br><br><br>if __name__ == &quot;__main__&quot;:<br>    HOST, PORT = &#x27;0.0.0.0&#x27;, 10005<br>    print(&quot;HOST:POST &quot; + HOST + &quot;:&quot; + str(PORT))<br>    server = ForkedServer((HOST, PORT), Task)<br>    server.allow_reuse_address = True<br>    server.serve_forever()<br></code></pre></td></tr></table></figure>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>首先是proof of work函数，简单的爆破四个字符使其连接上剩余已知字符的sha256等于函数给出的sha256值，然后进入正题，第一段守卫处没有有用信息，然后输入你的name(m1),之后可以在魔法喵喵那里获得</p>
<ul>
<li>getpermission<br>得到对m1+b’a_cat_permission’的AES_CBC加密之后得到的密文，其中iv是系统生成的已知量，key未知<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def getpermission(self, name, iv, key):<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    plain = Pad(name)+b&quot;a_cat_permission&quot;<br>    return aes.encrypt(plain)<br></code></pre></td></tr></table></figure></li>
<li>getmessage()<br>输入一段密文进行AES_CBC解密，iv由我们给出，key是之前用的，得到解密之后的明文<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def getmessage(self, iv, key, permission):<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    return aes.decrypt(permission)<br></code></pre></td></tr></table></figure>
共有三次询问的机会（循环次数为3），循环完成之后由守卫进行验证<br>提交给守卫某个密文和自己给出的偏移量iv，使得进行相同的key的AES_CBC解密之后得到的明文是m1<br>+b’Princeperimission’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">self.send(b&quot;Give me your permission:&quot;)<br>cipher = self.recv()<br>self.send(b&quot;What&#x27;s the cat tell you?&quot;)<br>iv = self.recv()<br>plain = self.getmessage(iv, self.key, cipher)<br>prs, uid = plain[16:],plain[:16]<br>if prs != b&#x27;Princepermission&#x27; or uid != self.name:<br></code></pre></td></tr></table></figure>
简单来说，我们就是需要想办法把从magic cat处得到的perimission &#x3D; m1 + b’a_cat_perimission’的密文转换为m1 + b’Princepermission’的密文，可以用到的是magic cat会提供一次或两次的解密机会(iv要自己给)，显然没有办法知道key进而求解，但是我们可以构造合适的iv，代入最后的AES_CBC解密<br>先令<br>m1&#x3D;input_name<br>m2&#x3D;a_cat_permission<br>need_m1&#x3D;m1<br>need_m2&#x3D;Princepermission</li>
</ul>
<p>由于AES_CBC加密是分块加密，而每一块的大小是128bits也就是16字节，而由于题目要求,m1和m2以及need_ m2都是16字节大小的<br>这就意味着加密得到的密文块会有特殊的性质</p>
<p>令c1 &#x3D; permission[:16] c_1&#x3D;permission[:16]<br>其中permission是 magic cat通过getpermission()给出的密文</p>
<p>通过图片明确一下AES_CBC加解密过程</p>
<p>加密过程是，先将明文按16字节一分组拆开，然后进行如图加密（先进行异或，非明文分组1的异或对象是前一个密文分组或者是明文分组1的异或对象初始化向量iv），再分别投入加密器，得到各个密文分组后拼接起来成为最后的密文</p>
<p>解密过程是，将密文按16字节一分组拆开，然后分别投入解密器，得到的结果与前一个密文分组或者初始化向量进行异或，最后得到各个明文分组再直接拼接在一起组成最后的明文<br class='item-img' data-src='/28fc17bdccff8a374a3a669530d1b16b-1.png'><img src="/28fc17bdccff8a374a3a669530d1b16b-1.png" alt="alt text"><br>其中加密器和解密器在本题算是黑盒，只需要知道进去的数据和原来是不一样的即可</p>
<p>我们构造的密文要先经过一次解密器，这就意味着非经过AES_CBC加密产生的密文(比如c1，c2)都会产生一个未知数据，那么这时候就需要用到magic cat的解密机会了<br>经过解密器异或之后，就是本题关键了，异或性质就是两个一样的数异或都是0，也就是说对其他一起的数不会有影响，利用这个性质构造:<br class='item-img' data-src='/QQ20250109-173454-1.png'><img src="/QQ20250109-173454-1.png" alt="alt text"><br class='item-img' data-src='/QQ20250109-173502-1.png'><img src="/QQ20250109-173502-1.png" alt="alt text"><br>解密代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from re import L<br>from pwn import *<br>import hashlib,string,random<br>from Crypto.Cipher import AES<br><br>io = remote(&quot;node4.buuoj.cn&quot;,&quot;27370&quot;)<br>temp = io.recvline()<br># print(temp)<br>temp1 = temp.split(b&quot;==&quot;)<br># print(temp1)<br>part_proof = bytes.decode(temp1[0].split(b&quot;XXXX&quot;)[1])[1:-2]<br>sha = bytes.decode(temp1[1]).strip()<br>table = string.ascii_letters + string.digits<br>while True:<br>    XXXX = &quot;&quot;.join([random.choice(table)for _ in range(4)])<br>    temp_proof = XXXX + part_proof<br>    temp_sha = hashlib.sha256(temp_proof.encode()).hexdigest()<br>    if sha == temp_sha:<br>        io.recvuntil(b&quot;[+] Give Me XXXX :&quot;)<br>        io.sendline(XXXX.encode())<br>        break<br>io.recvuntil(b&quot;[-] &quot;)<br>io.sendline(b&quot;1&quot;)<br>io.sendline(b&quot;1&quot; * 16)<br>io.recvuntil(b&#x27;Miao~ &#x27;)<br>iv = io.recvuntil(b&quot;\n&quot;)[:-1]<br># print(iv)<br>io.recvuntil(b&#x27;[-]&#x27;)<br>io.sendline(b&#x27;1&#x27;)<br>io.recvuntil(b&#x27;Permission:&#x27;)<br>cat_permission = io.recvline()[:-1]<br># print(cat_permission)<br>io.recvuntil(b&quot;[-]&quot;)<br>io.sendline(b&#x27;2&#x27;)<br>io.recvuntil(b&quot;Looks like you want to know something. Give me your permission:&quot;)<br><br>m2 = b&quot;a_cat_permission&quot;<br>m1 = b&#x27;1&#x27; * 16 # your name,直接16字节，不会进行pad()函数，如果那样的话，m1也会成为一个未知量<br>need_m2 = b&quot;Princepermission&quot;<br>need_m1 = m1<br>c1 = cat_permission[:16]<br>c2 = cat_permission[16:]<br>fake_c1 = xor(xor(c1,m2),need_m2)<br><br>io.sendline(fake_c1)<br>io.recvuntil(b&quot;Miao~ &quot;)<br>io.sendline(iv)<br>io.recvuntil(b&quot;The message is &quot;)<br>m = io.recvuntil(b&quot;\n&quot;)[:-1]<br># print(plain)<br>io.recvuntil(b&quot;[-]&quot;)<br>io.sendline(b&#x27;3&#x27;)<br>io.recvuntil(b&quot;Give me your permission:&quot;)<br><br>fake_permission = fake_c1 + c2<br>fake_iv = xor(xor(m,m1),iv)<br><br>io.sendline(fake_permission)<br>io.recvuntil(b&quot;What&#x27;s the cat tell you?&quot;)<br>io.sendline(fake_iv)<br>io.interactive()<br></code></pre></td></tr></table></figure>
<h3 id="3-CBC和ECB的联合求解"><a href="#3-CBC和ECB的联合求解" class="headerlink" title="3.CBC和ECB的联合求解"></a>3.CBC和ECB的联合求解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from Crypto.Cipher import AES<br>import binascii<br>from Crypto.Util.number import bytes_to_long<br>from flag import flag<br>from key import key<br><br>iv = flag.strip(b&#x27;d0g3&#123;&#x27;).strip(b&#x27;&#125;&#x27;)<br><br>LENGTH = len(key)<br>assert LENGTH == 16<br><br>hint = os.urandom(4) * 8<br>print(bytes_to_long(hint)^bytes_to_long(key))<br><br>msg = b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;<br><br>def encrypto(message):<br>    aes = AES.new(key,AES.MODE_CBC,iv)<br>    return aes.encrypt(message)<br><br>print(binascii.hexlify(encrypto(msg))[-32:])<br><br>&#x27;&#x27;&#x27;<br>56631233292325412205528754798133970783633216936302049893130220461139160682777<br>b&#x27;3c976c92aff4095a23e885b195077b66&#x27;<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure>
<p>从题目可知iv是由flag去掉前缀和后缀赋值得到的，所以解出iv就解出了flag，而题目给出的一大串数字是异或后的key，我们可以由<br>LENGTH &#x3D; len(key)<br>assert LENGTH &#x3D;&#x3D; 16</p>
<p>hint &#x3D; os.urandom(4) * 8<br>print(bytes_to_long(hint)^bytes_to_long(key))<br>知道，现key是由随机的四个重复字节与原key进行异或得到的，将这一串数字转为字节可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; from Crypto.Util.number import *<br>&gt;&gt;&gt; hint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777<br>&gt;&gt;&gt; long_to_bytes(hint_xor_key)<br>b&#x27;&#125;4$d&#125;4$d&#125;4$d&#125;4$d\x19\x04CW\x06CA\x08\x1e[I\x01\x04[Q\x19&#x27;<br></code></pre></td></tr></table></figure>
<p>有重复的字节}4$d,这就是hint的重复字节，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777<br>hint = long_to_bytes(hint_xor_key)[:4]<br>key = hint_xor_key ^ bytes_to_long(hint * 8)<br>key = long_to_bytes(key)<br></code></pre></td></tr></table></figure>
<p>题目最后是让消息转为十六进制并输出最后32个字符，说明输出的是最后一组密文，<br>则我们可以得到最终解密iv的代码:</p>
<figure class="highlight plaintext"><figcaption><span>Crypto.Cipher import AES</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs from">from Crypto.Util.number import *<br>from pwn import *<br>import binascii<br>hint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777<br>part_enc = b&#x27;3c976c92aff4095a23e885b195077b66&#x27;<br>msg = b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;<br># print(long_to_bytes(hint_xor_key))<br>hint = long_to_bytes(hint_xor_key)[:4]<br>key = hint_xor_key ^ bytes_to_long(hint * 8)<br>key = long_to_bytes(key)<br># print(len(msg))<br>aes = AES.new(key,AES.MODE_ECB)<br>part_enc = binascii.unhexlify(part_enc)<br>enc1 = part_enc<br>m1 = aes.decrypt(enc1)<br>enc2 = xor(msg[-16:],m1)<br>m2 = aes.decrypt(enc2)<br>enc3 = xor(msg[-32:-16],m2)<br>m3 = aes.decrypt(enc3)<br>enc4 = xor(msg[-48:-32],m3)<br>m4 = aes.decrypt(enc4)<br>enc5 = xor(msg[-64:-48],m4)<br>iv = enc5<br>print(iv)<br></code></pre></td></tr></table></figure>
<h3 id="4-单独涉及CTR模式"><a href="#4-单独涉及CTR模式" class="headerlink" title="4.单独涉及CTR模式"></a>4.单独涉及CTR模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import socketserver<br>import random<br>import os<br>import string<br>import binascii<br>import hashlib<br>from Crypto.Cipher import AES<br>from Crypto.Util import Counter <br>from Crypto.Util.number import getPrime<br>from hashlib import sha256<br>import gmpy2<br>from flag import flag<br><br>def init():<br>    q = getPrime(512)<br>    p = getPrime(512)<br>    e = getPrime(64)<br>    n = q*p<br>    phi = (q-1) * (p-1)<br>    d = gmpy2.invert(e, phi)<br>    hint = 2 * d + random.randint(0, 2**16) * e * phi<br>    mac = random.randint(0, 2**64)<br>    c = pow(mac, e, n)<br>    counter = random.randint(0, 2**128)<br>    key = os.urandom(16)<br>    score = 0<br>    return n, hint, c, counter, key, mac, score<br><br>class task(socketserver.BaseRequestHandler):<br><br>    def POW(self):<br>        random.seed(os.urandom(8))<br>        proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)])<br>        result = hashlib.sha256(proof.encode(&#x27;utf-8&#x27;)).hexdigest()<br>        self.request.sendall((&quot;sha256(XXXX+%s) == %s\n&quot; % (proof[4:],result)).encode())<br>        self.request.sendall(b&#x27;Give me XXXX:\n&#x27;)<br>        x = self.recv()<br>        <br>        if len(x) != 4 or hashlib.sha256((x+proof[4:].encode())).hexdigest() != result: <br>            return False<br>        return True<br><br>    def recv(self):<br>        BUFF_SIZE = 2048<br>        data = b&#x27;&#x27;<br>        while True:<br>            part = self.request.recv(BUFF_SIZE)<br>            data += part<br>            if len(part) &lt; BUFF_SIZE:<br>                break<br>        return data.strip()<br><br>    def padding(self, msg):<br>        return  msg + chr((16 - len(msg)%16)).encode() * (16 - len(msg)%16)<br><br>    def encrypt(self, msg):<br>        msg = self.padding(msg)<br>        if self.r != -1:<br>            self.r += 1<br>            aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))<br>            return aes.encrypt(msg)<br>        else:<br>            return msg<br><br>    def send(self, msg, enc=True):<br>        print(msg, end= &#x27;   &#x27;)<br>        if enc:<br>            msg = self.encrypt(msg)<br>        print(msg, self.r)<br>        self.request.sendall(binascii.hexlify(msg) + b&#x27;\n&#x27;)<br><br>    def set_key(self, rec):<br>        if self.mac == int(rec[8:]):<br>            self.r = self.counter<br><br>    def guess_num(self, rec):<br>        num = random.randint(0, 2**128)<br>        if num == int(rec[10:]):<br>            self.send(b&#x27;right&#x27;)<br>            self.score += 1<br>        else:<br>            self.send(b&#x27;wrong&#x27;)<br><br>    def get_flag(self, rec):<br>        assert self.r != -1<br>        if self.score ==  5:<br>            self.send(flag, enc=False)<br>        else:<br>            self.send(os.urandom(32) +  flag)<br><br>    def handle(self):<br>        self.r = -1<br><br>        if not self.POW():<br>            self.send(b&#x27;Error Hash!&#x27;, enc= False)<br>            return<br><br>        self.n, self.hint, self.c ,self.counter, self.key, self.mac, self.score = init()<br><br>        self.send(str(self.n).encode(), enc = False)<br>        self.send(str(self.hint).encode(), enc = False)<br>        self.send(str(self.c).encode(), enc = False)<br><br>        for _ in range(6):<br>            rec = self.recv()<br>            if rec[:8] == b&#x27;set key:&#x27;:<br>                self.set_key(rec)<br>            elif rec[:10] == b&#x27;guess num:&#x27;:<br>                self.guess_num(rec)<br>            elif rec[:8] == b&#x27;get flag&#x27;:<br>                self.get_flag(rec)<br>            else:<br>                self.send(b&#x27;something wrong, check your input&#x27;)<br><br>class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):<br>    pass<br><br>def main():<br>    HOST, PORT = &#x27;127.0.0.1&#x27;, 10086<br>    server = ForkedServer((HOST, PORT), task)<br>    server.allow_reuse_address = True<br>    server.serve_forever()<br><br>if __name__ == &#x27;__main__&#x27;:<br>    main()<br></code></pre></td></tr></table></figure>
<p>这是一道经典的nc连接题，用了套接字模块，重点函数是handle()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def handle(self):<br>    self.r = -1<br><br>    if not self.POW():<br>        self.send(b&#x27;Error Hash!&#x27;, enc= False)<br>        return<br><br>    self.n, self.hint, self.c ,self.counter, self.key, self.mac, self.score = init()<br><br>    self.send(str(self.n).encode(), enc = False)<br>    self.send(str(self.hint).encode(), enc = False)<br>    self.send(str(self.c).encode(), enc = False)<br><br>    for _ in range(6):<br>        rec = self.recv()<br>        if rec[:8] == b&#x27;set key:&#x27;:<br>            self.set_key(rec)<br>        elif rec[:10] == b&#x27;guess num:&#x27;:<br>            self.guess_num(rec)<br>        elif rec[:8] == b&#x27;get flag&#x27;:<br>            self.get_flag(rec)<br>        else:<br>            self.send(b&#x27;something wrong, check your input&#x27;)<br></code></pre></td></tr></table></figure>
<p>先进行POW函数验证，就是判断hash值，爆破就行(就是去爆破下图的XXXX)<br class='item-img' data-src='/QQ20250109-202839-1.png'><img src="/QQ20250109-202839-1.png" alt="alt text"><br>按照RSA加密的方式给出了n，c和hint(服务端这几个值都是十六进制，要先转十进制)，且加密的明文是mac，先求它:<br class='item-img' data-src='/QQ20250109-203005-1.png'><img src="/QQ20250109-203005-1.png" alt="alt text"><br>所以mac&#x3D;gmpy2.iroot(pow(c,hint,n),2)[0];需要知道mac作用<br>再来看到之后提供三种选择，set key，guess num，get flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def set_key(self, rec):<br>    if self.mac == int(rec[8:]):<br>        self.r = self.counter<br></code></pre></td></tr></table></figure>
<p>似乎是判定输入的内容是否和mac一致，若一致，则进行一个赋值操作，看到是将counter赋值给r<br>寻找counter的生成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def init():<br>    ...<br>    counter = random.randint(0, 2**128)<br></code></pre></td></tr></table></figure>
<p>就是一个随机数，而self.r的初始值为-1<br>由encrypt()函数可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def encrypt(self, msg):<br>    msg = self.padding(msg)<br>    if self.r != -1:<br>        self.r += 1<br>        aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))<br>        return aes.encrypt(msg)<br>    else:<br>        return msg<br></code></pre></td></tr></table></figure>
<p>如果self.r的值没有改变的话，也就是说没有进行set key操作的话，AES_CRT加密过程就不会生效；加密不生效就可以直接拿flag吗，再来看到get flag操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def get_flag(self, rec):<br>    assert self.r != -1<br>    if self.score ==  5:<br>        self.send(flag, enc=False)<br>    else:<br>        self.send(os.urandom(32) +  flag)<br></code></pre></td></tr></table></figure>
<p>有个assert self.r !&#x3D; -1，意味着必须self.r被随机生成的counter赋值才能进行get flag，否则会直接assert报错</p>
<p>三种选择中还剩下一个guess num操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def guess_num(self, rec):<br>    num = random.randint(0, 2**128)<br>    if num == int(rec[10:]):<br>        self.send(b&#x27;right&#x27;)<br>        self.score += 1<br>    else:<br>        self.send(b&#x27;wrong&#x27;)<br></code></pre></td></tr></table></figure>
<p>如果猜对随即生成的数字，则使得self.score +&#x3D; 1，而self.score的作用是在get flag中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if self.score ==  5:<br>    self.send(flag, enc=False)<br></code></pre></td></tr></table></figure>
<p>意味着连续猜中5次则能使得get flag操作直接返回flag</p>
<p>但是细看一下，首先随机数生成的范围很大，不可能爆破；只能猜测一次，否则会在6次选择中浪费一次机会；最重要的是，6次选择中有一次机会必须用来set key（否则无法进行get flag操作），有一次机会用来get flag，只剩下4次机会，而我们需要连续猜中5次随机数；所以guess num操作在现在看来就是一个幌子</p>
<p>那么要获得flag只能从encrypt函数下手<br>这是一个CTR加密<br class='item-img' data-src='/157d4fdca90a29c8335c0e3ab5deeb66-1.png'><img src="/157d4fdca90a29c8335c0e3ab5deeb66-1.png" alt="alt text"><br>计数器CTR就是可以生成随机的初始值IV，而后每次加密序号都有递增<br>生成过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from Crypto.Util import Counter <br>aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))<br></code></pre></td></tr></table></figure>
<p>看得出来是Counter.new(128, initial_value&#x3D;self.r))中initial_value变量在设置CTR的初始值</p>
<p>而CTR所表示的值也不是简单的00，01，而是一组由随机数nonce和分组序号组成的初始值<br>每加密一个明文分组，CTR的分组序号则会+1，使得进行加密操作之后的加密流与之前的加密流完全不同，达到与各个明文分组进行异或的字节串互不相同<br>注:加密操作是指CTR生成后马上进行加密器的操作</p>
<ul>
<li><p>解密过程<br class='item-img' data-src='/8abf5eea9e15cd319f58697c4cda28ef-1.png'><img src="/8abf5eea9e15cd319f58697c4cda28ef-1.png"><br>可以发现就是重置计数器CTR使其在对应的密文分组上产生与加密时一样的CTR，再将其进行加密操作，生成与加密过程中一样的加密流，与密文分组异或即得到明文分组<br>我们发现加解密其实就两大块，CTR加密和异或；</p>
<ul>
<li>再回到题目脚本，这里容易发现，在每次服务器脚本send的时候，函数中很多地方都是send(x,enc &#x3D; False)，可以找到脚本中自己定义的send函数</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def send(self, msg, enc=True):<br>    print(msg, end= &#x27;   &#x27;)<br>    if enc:<br>        msg = self.encrypt(msg)<br>    print(msg, self.r)<br>    self.request.sendall(binascii.hexlify(msg) + b&#x27;\n&#x27;)<br></code></pre></td></tr></table></figure>
<p>作用就是写出enc &#x3D; False的send函数里面，会直接输出内容，也就是正常交互过程中的send函数；而当enc &#x3D; True，或者说send函数里面没有对enc进行再赋值，那么输出的内容会进行encrypt()加密，也就是AES_CTR加密<br>仔细观察可以发现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">self.send(b&#x27;something wrong, check your input&#x27;)<br>if num == int(rec[10:]):<br>    self.send(b&#x27;right&#x27;)<br>    self.score += 1<br>else:<br>    self.send(b&#x27;wrong&#x27;)<br></code></pre></td></tr></table></figure>
<p>这里的send函数返回的实际上不是明文right，something wrong…；而是AES_CTR加密后的密文（也可以在本地测试debug的时候发现这个特征）</p>
<p>不可能无缘无故地把这些返回内容设置为加密之后再返回，所以这里一定是突破点</p>
<p>现在我们可以得到一对明密文，AES_CTR加密后的flag；加密密钥key未知也无法知道，显然不能通过正常求密钥key来解密</p>
<p>总共给予了6次选择的机会，那如果我们多得到几组明密文，有什么用呢</p>
<p>在AES_CTR加密中，如果我们已知明文以及对应的密文，将两者异或即可得到加密流，因为加密过程中<br class='item-img' data-src='/QQ20250109-210358-1.png'><img src="/QQ20250109-210358-1.png" alt="alt text"><br>而加密流是由不同的CTR生成的，如果我们多收集一些加密流拼接在一起，再用来和加密后的flag进行异或，不就模拟了AES_CTR模式的解密过程吗</p>
<p>那么最终的问题就是我们需要哪些加密流，也就是说哪些加密流是加密flag的时候真正使用的</p>
<p>加密流当然是越长越好，所以我们使用something wrong…作为明密文组求得加密流，默认经过padding函数后明文长度为48</p>
<p>正常情况下（本题不是这样的正常情况，之后会提到，也是关键点之一）是得到的加密流应该是由CTR，CTR+1，CTR+2生成的，那么很可能不够长足以使得与加密之后的flag异或可以得到完整的flag（因为flag加密过程中是作为padding(os.urandom(32)+flag)进行加密的，所以密文会比较长）</p>
<p>那么现在有一个疑惑就是如果连续加密两次及以上的话，counter会不会自动继续+1，使得我们确实可以将对不同的加密过程（虽然明文确实是相同的）中生成的多个加密流按照CTR+i的顺序拼接在一起，作为一整个加密流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; from Crypto.Cipher import AES<br>&gt;&gt;&gt; from Crypto.Util import Counter<br>&gt;&gt;&gt; from pwn import *<br>&gt;&gt;&gt; key = b&#x27;\x01&#x27; * 16<br>&gt;&gt;&gt; msg = b&quot;flag1111111111111111111111111111111111111111111111111111111&quot;<br>&gt;&gt;&gt; t = Counter.new(128, initial_value=123)<br>&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)<br>&gt;&gt;&gt; enc1 = aes.encrypt(msg)<br>&gt;&gt;&gt; enc1<br>b&quot;0=J\xe6\x87\xec\x07r\xf1&#123;L\x94\xf7\xf2\xfcp|-\xf0\xca\xba\xe4:\x89\x7f\rI\xb5\x84\xb8\x00\xe2%(\x02o\xa5\x8c\xa3\x93\x18&#x27;\xb0\xa2\xe2\xd4]\xb1*\xb5\x8fH7\xd8\xfa\x8f\x08\xe7X&quot;<br>&gt;&gt;&gt; enc2 = aes.encrypt(msg)<br>&gt;&gt;&gt; enc2<br>b&#x27;\x97\xf5\xe3_\xdc\xb3\x1c\x11\x1fM\n\x16\x06&#125;:hvU\x1d\x93&quot;\xf6\x89\xc3\x05\x94\x8b&gt;6ha\xce\&#x27;\x9f\xb5$\x07Hm\xa5\xd1]y)P\xff\xd3e\xea\x7f\xa9\xb3\xe9\xcd\x88\x97&gt;\x8d\xad&#x27;<br></code></pre></td></tr></table></figure>
<p>实践证明确实可以将不同加密过程中得到的加密流拼接在一起，但是如何确保对flag加密的加密流和我们求得的加密流一致呢，那就是重复使用set key操作</p>
<p>大致重演一下重复使用set key的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; from Crypto.Cipher import AES<br>&gt;&gt;&gt; from Crypto.Util import Counter<br>&gt;&gt;&gt; from pwn import *<br>&gt;&gt;&gt; key = b&#x27;\x01&#x27; * 16<br>&gt;&gt;&gt; msg = b&quot;flag1111111111111111111111111111111111111111111111111111111&quot;<br>&gt;&gt;&gt; t = Counter.new(128, initial_value=123)<br>&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)<br>&gt;&gt;&gt; enc1 = aes.encrypt(msg)<br>&gt;&gt;&gt; enc2 = aes.encrypt(msg)<br>&gt;&gt;&gt; t = Counter.new(128, initial_value=123)<br>&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)<br>&gt;&gt;&gt; enc3 = aes.encrypt(msg)<br>&gt;&gt;&gt; enc4 = aes.encrypt(msg)<br>&gt;&gt;&gt; assert xor(enc1,msg) == xor(enc3,msg)<br>&gt;&gt;&gt; assert xor(enc2,msg) == xor(enc4,msg)<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>
<p>意思就是当我们重复对counter进行赋相同的值时，整个CTR初始值会被刷新</p>
<p>那么我们是不是只需要两到三个something wrong…明密文对得到的加密流拼接在一起与flag进行异或就好了呢</p>
<p>实践发现只能得到一半的flag，刚好就是前48位的padding(os.urandom(32)+flag)；之后的加密流为什么不是正确对应的呢</p>
<p>发现作者在self.r和aes上面动了手脚，在每次加密整个明文之前self.r会自己首先+1，也就是CTR + 1；并且在每次加密整个明文之前都会重新定义一遍 aes &#x3D; AES.new(self.key, AES.MODE_CTR, counter &#x3D; Counter.new(128, initial_value&#x3D;self.r))，这就意味着对两次明文（不是明文分组）加密中所使用两个的CTR生成的加密流中，上一个明文的最后一组明文分组使用的是CTR + i，下一个明文的第一组明文分组的不是CTR + i + 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def encrypt(self, msg):<br>    msg = self.padding(msg)<br>    if self.r != -1:<br>        self.r += 1<br>        aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))<br>        return aes.encrypt(msg)<br>    else:<br>        return msg<br></code></pre></td></tr></table></figure>
<p>所以加密过程中的加密流实际上是CTR + 1，CTR + 2，CTR + 3等等通过加密操作生成的</p>
<p>并且上一个明文（不是明文分组）加密所涉及的CTR初始值是CTR + 1，下一个明文加密所涉及的CTR初始值是CTR + 2（因为每次加密整个明文之前self.r +&#x3D; 1）</p>
<p>所以<br class='item-img' data-src='/QQ20250109-210946-1.png'><img src="/QQ20250109-210946-1.png"><br>其中mi是somgthing srong…的明文，意思是该明文在前后的加密过程中所使用的加密流是由以上CTR + i生成的</p>
<p>为了使得flag使用的是已知的加密流，我们使用set key操作把CTR刷新，使得<br class='item-img' data-src='/QQ20250109-211052-1.png'><img src="/QQ20250109-211052-1.png" alt="alt text"><br>那么对mi进行对应的截取即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>from Crypto.Util.number import *<br>import gmpy2<br>import hashlib<br>import string<br>import random<br>import binascii<br><br>context.log_level=&#x27;debug&#x27;<br>io = remote(&quot;192.168.109.129&quot;,&quot;9998&quot;)<br>io.recvuntil(b&quot;+&quot;)<br>tmp = io.recvuntil(b&quot;\n&quot;)<br>part_proof = tmp.split(b&quot;) == &quot;)[0]<br>result = tmp.split(b&quot;) == &quot;)[1][:-1]<br>table = string.ascii_letters + string.digits<br>while True:<br>    XXXX = (&quot;&quot;.join(random.sample(table,4))).encode()<br>    if hashlib.sha256(XXXX + part_proof).hexdigest() == result.decode():<br>        io.recvuntil(b&quot;\n&quot;)<br>        io.sendline(XXXX)<br>        break<br><br>n = int(binascii.unhexlify(io.recvline()[:-1]))<br>hint = int(binascii.unhexlify(io.recvline()[:-1]))<br>c =  int(binascii.unhexlify(io.recvline()[:-1]))<br>mac = gmpy2.iroot(pow(c,hint,n) % n,2)[0]<br><br><br>io.sendline(b&quot;set key:&quot; + str(mac).encode())<br>enc = []<br>for _ in range(3):<br>    io.sendline(b&quot;I_want_flag&quot;)<br>    time.sleep(0.5)<br>    tmp = io.recvline()[:-1].decode()<br>    if _ != 2:<br>        enc.append(long_to_bytes(int(str(tmp),16))[:16])<br>    else:<br>        enc.append(long_to_bytes(int(str(tmp),16)))<br># print(enc)<br>io.sendline(b&quot;set key:&quot; + str(mac).encode())<br>time.sleep(0.5)<br>io.sendline(b&quot;get flag&quot;)<br>time.sleep(0.5)<br>tmp = io.recvline()<br>enc_flag = binascii.unhexlify(tmp[:-1])<br><br>msg = b&#x27;something wrong, check your input&#x27;<br>msg = msg + chr((16 - len(msg)%16)).encode() * (16 - len(msg)%16)<br>key_stream = b&quot;&quot;<br>for i in enc:<br>    key_stream += xor(i,msg[:len(i)]) <br>print(xor(enc_flag,key_stream[:len(enc_flag)]))<br></code></pre></td></tr></table></figure>
<p>关于AES的深入一点的题目都是交互式的，正常情况不会要求求密钥key，而是利用xor的特性以及加密器（相当于黑盒加密）来从服务器脚本处骗取可以求得flag的数值</p>
<p>关于交互式的题目没有头绪的时候更倾向于直接与服务端进行交互查看debug返回，而不单是查看服务器所使用的脚本</p>
<p>Crypto的交互式题目需要注意服务端返回的内容是什么类型的，很可能脚本会对十进制数值转字节再转十六进制，可能要进行一定的数据处理</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/01/23/Coppersmith%E6%94%BB%E5%87%BB/">← Next Coppersmith攻击</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/01/16/AES/">AES Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Y1yang788</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E7%8B%AC%E6%B6%89%E5%8F%8AECB%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1.单独涉及ECB模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E7%8B%AC%E6%B6%89%E5%8F%8ACBC%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2.单独涉及CBC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CBC%E5%92%8CECB%E7%9A%84%E8%81%94%E5%90%88%E6%B1%82%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">3.CBC和ECB的联合求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E7%8B%AC%E6%B6%89%E5%8F%8ACTR%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">4.单独涉及CTR模式</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>