[{"title":"AES题型","url":"/2025/01/17/AES%E9%A2%98%E5%9E%8B/","content":"1.单独涉及ECB模式最常见的是RSA中套了一个简单的AES_ECB加密，就是AES加密flag，只要先将用RSA加密的key解出，就能解的flag\n2.单独涉及CBC模式from Crypto.Cipher import AESimport osfrom hashlib import sha256import socketserverimport signalimport stringimport randomtable = string.ascii_letters + string.digitsBANNER = br&#x27;&#x27;&#x27; .d8888b.  d8b                   888                            888             d88P  Y88b Y8P                   888                            888             888    888                       888                            888             888        888 888  888  .d88b.  888888        .d8888b  8888b.  888888          888        888 888  888 d8P  Y8b 888          d88P&quot;        &quot;88b 888             888    888 888 Y88  88P 88888888 888          888      .d888888 888             Y88b  d88P 888  Y8bd8P  Y8b.     Y88b.        Y88b.    888  888 Y88b.            &quot;Y8888P&quot;  888   Y88P    &quot;Y8888   &quot;Y888        &quot;Y8888P &quot;Y888888  &quot;Y888                                                                                                                                                                                                                                                           .d888                        8888888b.          d8b                            d88P&quot;                         888   Y88b         Y8P                            888                           888    888                                        888888  .d88b.  888d888       888   d88P 888d888 888 88888b.   .d8888b  .d88b.  888    d88&quot;&quot;88b 888P&quot;         8888888P&quot;  888P&quot;   888 888 &quot;88b d88P&quot;    d8P  Y8b 888    888  888 888           888        888     888 888  888 888      88888888 888    Y88..88P 888           888        888     888 888  888 Y88b.    Y8b.     888     &quot;Y88P&quot;  888           888        888     888 888  888  &quot;Y8888P  &quot;Y8888&#x27;&#x27;&#x27;guard_menu = br&#x27;&#x27;&#x27;1.Tell the guard my name2.Go away&#x27;&#x27;&#x27;cat_menu = br&#x27;&#x27;&#x27;1.getpermission2.getmessage3.say Goodbye&#x27;&#x27;&#x27;def Pad(msg):    return msg + os.urandom((16 - len(msg) % 16) % 16)class Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b&#x27;&#x27;        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        try:            if newline:                msg += b&#x27;\\n&#x27;            self.request.sendall(msg)        except:            pass    def recv(self, prompt=b&#x27;[-] &#x27;):        self.send(prompt, newline=False)        return self._recvall()    def proof_of_work(self):        proof = (&#x27;&#x27;.join([random.choice(table) for _ in range(12)])).encode()        sha = sha256(proof).hexdigest().encode()        self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha)        XXXX = self.recv(prompt=b&#x27;[+] Give Me XXXX :&#x27;)        if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha:            return False        return True    def register(self):        self.send(b&#x27;&#x27;)        username = self.recv()        return username    def getpermission(self, name, iv, key):        aes = AES.new(key, AES.MODE_CBC, iv)        plain = Pad(name)+b&quot;a_cat_permission&quot;        return aes.encrypt(plain)    def getmessage(self, iv, key, permission):        aes = AES.new(key, AES.MODE_CBC, iv)        return aes.decrypt(permission)    def handle(self):        signal.alarm(50)        if not self.proof_of_work():            return        self.send(BANNER, newline=False)        self.key = os.urandom(16)        self.iv = os.urandom(16)        self.send(b&quot;I&#x27;m the guard, responsible for protecting the prince&#x27;s safety.&quot;)        self.send(b&quot;You shall not pass, unless you have the permission of the prince.&quot;)        self.send(b&quot;You have two choices now. Tell me who you are or leave now!&quot;)        self.send(guard_menu, newline=False)        option = self.recv()        if option == b&#x27;1&#x27;:            try:                self.name = self.register()                self.send(b&quot;Hello &quot; + self.name)                self.send(b&quot;Nice to meet you. But I can&#x27;t let you pass. I can give you a cat. She will play with you&quot;)                self.send(b&#x27;Miao~ &#x27; + self.iv)                for i in range(3):                    self.send(b&quot;I&#x27;m a magic cat. What can I help you&quot;)                    self.send(cat_menu, newline=False)                    op = self.recv()                    if op == b&#x27;1&#x27;:                        self.send(b&quot;Looks like you want permission. Here you are~&quot;)                        permission = self.getpermission(self.name, self.iv, self.key)                        self.send(b&quot;Permission:&quot; + permission)                    elif op == b&#x27;2&#x27;:                        self.send(b&quot;Looks like you want to know something. Give me your permission:&quot;)                        permission = self.recv()                        self.send(b&quot;Miao~ &quot;)                        iv = self.recv()                        plain = self.getmessage(iv, self.key, permission)                        self.send(b&quot;The message is &quot; + plain)                    elif op == b&#x27;3&#x27;:                        self.send(b&quot;I&#x27;m leaving. Bye~&quot;)                        break                self.send(b&quot;Oh, you&#x27;re here again. Let me check your permission.&quot;)                self.send(b&quot;Give me your permission:&quot;)                cipher = self.recv()                self.send(b&quot;What&#x27;s the cat tell you?&quot;)                iv = self.recv()                plain = self.getmessage(iv, self.key, cipher)                prs, uid = plain[16:],plain[:16]                if prs != b&#x27;Princepermission&#x27; or uid != self.name:                    self.send(b&quot;You don&#x27;t have the Prince Permission. Go away!&quot;)                    return                else:                    self.send(b&quot;Unbelievable! How did you get it!&quot;)                    self.send(b&quot;The prince asked me to tell you this:&quot;)                    f = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;)                    flag = f.read()                    f.close()                    self.send(flag)            except:                self.request.close()        if option == b&#x27;2&#x27;:            self.send(b&quot;Stay away from here!&quot;)        self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passif __name__ == &quot;__main__&quot;:    HOST, PORT = &#x27;0.0.0.0&#x27;, 10005    print(&quot;HOST:POST &quot; + HOST + &quot;:&quot; + str(PORT))    server = ForkedServer((HOST, PORT), Task)    server.allow_reuse_address = True    server.serve_forever()\n分析：首先是proof of work函数，简单的爆破四个字符使其连接上剩余已知字符的sha256等于函数给出的sha256值，然后进入正题，第一段守卫处没有有用信息，然后输入你的name(m1),之后可以在魔法喵喵那里获得\n\ngetpermission得到对m1+b’a_cat_permission’的AES_CBC加密之后得到的密文，其中iv是系统生成的已知量，key未知def getpermission(self, name, iv, key):    aes = AES.new(key, AES.MODE_CBC, iv)    plain = Pad(name)+b&quot;a_cat_permission&quot;    return aes.encrypt(plain)\ngetmessage()输入一段密文进行AES_CBC解密，iv由我们给出，key是之前用的，得到解密之后的明文def getmessage(self, iv, key, permission):    aes = AES.new(key, AES.MODE_CBC, iv)    return aes.decrypt(permission)\n共有三次询问的机会（循环次数为3），循环完成之后由守卫进行验证提交给守卫某个密文和自己给出的偏移量iv，使得进行相同的key的AES_CBC解密之后得到的明文是m1+b’Princeperimission’self.send(b&quot;Give me your permission:&quot;)cipher = self.recv()self.send(b&quot;What&#x27;s the cat tell you?&quot;)iv = self.recv()plain = self.getmessage(iv, self.key, cipher)prs, uid = plain[16:],plain[:16]if prs != b&#x27;Princepermission&#x27; or uid != self.name:\n简单来说，我们就是需要想办法把从magic cat处得到的perimission &#x3D; m1 + b’a_cat_perimission’的密文转换为m1 + b’Princepermission’的密文，可以用到的是magic cat会提供一次或两次的解密机会(iv要自己给)，显然没有办法知道key进而求解，但是我们可以构造合适的iv，代入最后的AES_CBC解密先令m1&#x3D;input_namem2&#x3D;a_cat_permissionneed_m1&#x3D;m1need_m2&#x3D;Princepermission\n\n由于AES_CBC加密是分块加密，而每一块的大小是128bits也就是16字节，而由于题目要求,m1和m2以及need_ m2都是16字节大小的这就意味着加密得到的密文块会有特殊的性质\n令c1 &#x3D; permission[:16] c_1&#x3D;permission[:16]其中permission是 magic cat通过getpermission()给出的密文\n通过图片明确一下AES_CBC加解密过程\n加密过程是，先将明文按16字节一分组拆开，然后进行如图加密（先进行异或，非明文分组1的异或对象是前一个密文分组或者是明文分组1的异或对象初始化向量iv），再分别投入加密器，得到各个密文分组后拼接起来成为最后的密文\n解密过程是，将密文按16字节一分组拆开，然后分别投入解密器，得到的结果与前一个密文分组或者初始化向量进行异或，最后得到各个明文分组再直接拼接在一起组成最后的明文其中加密器和解密器在本题算是黑盒，只需要知道进去的数据和原来是不一样的即可\n我们构造的密文要先经过一次解密器，这就意味着非经过AES_CBC加密产生的密文(比如c1，c2)都会产生一个未知数据，那么这时候就需要用到magic cat的解密机会了经过解密器异或之后，就是本题关键了，异或性质就是两个一样的数异或都是0，也就是说对其他一起的数不会有影响，利用这个性质构造:解密代码:\nfrom re import Lfrom pwn import *import hashlib,string,randomfrom Crypto.Cipher import AESio = remote(&quot;node4.buuoj.cn&quot;,&quot;27370&quot;)temp = io.recvline()# print(temp)temp1 = temp.split(b&quot;==&quot;)# print(temp1)part_proof = bytes.decode(temp1[0].split(b&quot;XXXX&quot;)[1])[1:-2]sha = bytes.decode(temp1[1]).strip()table = string.ascii_letters + string.digitswhile True:    XXXX = &quot;&quot;.join([random.choice(table)for _ in range(4)])    temp_proof = XXXX + part_proof    temp_sha = hashlib.sha256(temp_proof.encode()).hexdigest()    if sha == temp_sha:        io.recvuntil(b&quot;[+] Give Me XXXX :&quot;)        io.sendline(XXXX.encode())        breakio.recvuntil(b&quot;[-] &quot;)io.sendline(b&quot;1&quot;)io.sendline(b&quot;1&quot; * 16)io.recvuntil(b&#x27;Miao~ &#x27;)iv = io.recvuntil(b&quot;\\n&quot;)[:-1]# print(iv)io.recvuntil(b&#x27;[-]&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;Permission:&#x27;)cat_permission = io.recvline()[:-1]# print(cat_permission)io.recvuntil(b&quot;[-]&quot;)io.sendline(b&#x27;2&#x27;)io.recvuntil(b&quot;Looks like you want to know something. Give me your permission:&quot;)m2 = b&quot;a_cat_permission&quot;m1 = b&#x27;1&#x27; * 16 # your name,直接16字节，不会进行pad()函数，如果那样的话，m1也会成为一个未知量need_m2 = b&quot;Princepermission&quot;need_m1 = m1c1 = cat_permission[:16]c2 = cat_permission[16:]fake_c1 = xor(xor(c1,m2),need_m2)io.sendline(fake_c1)io.recvuntil(b&quot;Miao~ &quot;)io.sendline(iv)io.recvuntil(b&quot;The message is &quot;)m = io.recvuntil(b&quot;\\n&quot;)[:-1]# print(plain)io.recvuntil(b&quot;[-]&quot;)io.sendline(b&#x27;3&#x27;)io.recvuntil(b&quot;Give me your permission:&quot;)fake_permission = fake_c1 + c2fake_iv = xor(xor(m,m1),iv)io.sendline(fake_permission)io.recvuntil(b&quot;What&#x27;s the cat tell you?&quot;)io.sendline(fake_iv)io.interactive()\n3.CBC和ECB的联合求解from Crypto.Cipher import AESimport binasciifrom Crypto.Util.number import bytes_to_longfrom flag import flagfrom key import keyiv = flag.strip(b&#x27;d0g3&#123;&#x27;).strip(b&#x27;&#125;&#x27;)LENGTH = len(key)assert LENGTH == 16hint = os.urandom(4) * 8print(bytes_to_long(hint)^bytes_to_long(key))msg = b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;def encrypto(message):    aes = AES.new(key,AES.MODE_CBC,iv)    return aes.encrypt(message)print(binascii.hexlify(encrypto(msg))[-32:])&#x27;&#x27;&#x27;56631233292325412205528754798133970783633216936302049893130220461139160682777b&#x27;3c976c92aff4095a23e885b195077b66&#x27;&#x27;&#x27;&#x27;\n从题目可知iv是由flag去掉前缀和后缀赋值得到的，所以解出iv就解出了flag，而题目给出的一大串数字是异或后的key，我们可以由LENGTH &#x3D; len(key)assert LENGTH &#x3D;&#x3D; 16\nhint &#x3D; os.urandom(4) * 8print(bytes_to_long(hint)^bytes_to_long(key))知道，现key是由随机的四个重复字节与原key进行异或得到的，将这一串数字转为字节可以看到：\n&gt;&gt;&gt; from Crypto.Util.number import *&gt;&gt;&gt; hint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777&gt;&gt;&gt; long_to_bytes(hint_xor_key)b&#x27;&#125;4$d&#125;4$d&#125;4$d&#125;4$d\\x19\\x04CW\\x06CA\\x08\\x1e[I\\x01\\x04[Q\\x19&#x27;\n有重复的字节}4$d,这就是hint的重复字节，那么：\nhint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777hint = long_to_bytes(hint_xor_key)[:4]key = hint_xor_key ^ bytes_to_long(hint * 8)key = long_to_bytes(key)\n题目最后是让消息转为十六进制并输出最后32个字符，说明输出的是最后一组密文，则我们可以得到最终解密iv的代码:\nCrypto.Cipher import AESfrom Crypto.Util.number import *from pwn import *import binasciihint_xor_key = 56631233292325412205528754798133970783633216936302049893130220461139160682777part_enc = b&#x27;3c976c92aff4095a23e885b195077b66&#x27;msg = b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;# print(long_to_bytes(hint_xor_key))hint = long_to_bytes(hint_xor_key)[:4]key = hint_xor_key ^ bytes_to_long(hint * 8)key = long_to_bytes(key)# print(len(msg))aes = AES.new(key,AES.MODE_ECB)part_enc = binascii.unhexlify(part_enc)enc1 = part_encm1 = aes.decrypt(enc1)enc2 = xor(msg[-16:],m1)m2 = aes.decrypt(enc2)enc3 = xor(msg[-32:-16],m2)m3 = aes.decrypt(enc3)enc4 = xor(msg[-48:-32],m3)m4 = aes.decrypt(enc4)enc5 = xor(msg[-64:-48],m4)iv = enc5print(iv)\n4.单独涉及CTR模式import socketserverimport randomimport osimport stringimport binasciiimport hashlibfrom Crypto.Cipher import AESfrom Crypto.Util import Counter from Crypto.Util.number import getPrimefrom hashlib import sha256import gmpy2from flag import flagdef init():    q = getPrime(512)    p = getPrime(512)    e = getPrime(64)    n = q*p    phi = (q-1) * (p-1)    d = gmpy2.invert(e, phi)    hint = 2 * d + random.randint(0, 2**16) * e * phi    mac = random.randint(0, 2**64)    c = pow(mac, e, n)    counter = random.randint(0, 2**128)    key = os.urandom(16)    score = 0    return n, hint, c, counter, key, mac, scoreclass task(socketserver.BaseRequestHandler):    def POW(self):        random.seed(os.urandom(8))        proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)])        result = hashlib.sha256(proof.encode(&#x27;utf-8&#x27;)).hexdigest()        self.request.sendall((&quot;sha256(XXXX+%s) == %s\\n&quot; % (proof[4:],result)).encode())        self.request.sendall(b&#x27;Give me XXXX:\\n&#x27;)        x = self.recv()                if len(x) != 4 or hashlib.sha256((x+proof[4:].encode())).hexdigest() != result:             return False        return True    def recv(self):        BUFF_SIZE = 2048        data = b&#x27;&#x27;        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def padding(self, msg):        return  msg + chr((16 - len(msg)%16)).encode() * (16 - len(msg)%16)    def encrypt(self, msg):        msg = self.padding(msg)        if self.r != -1:            self.r += 1            aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))            return aes.encrypt(msg)        else:            return msg    def send(self, msg, enc=True):        print(msg, end= &#x27;   &#x27;)        if enc:            msg = self.encrypt(msg)        print(msg, self.r)        self.request.sendall(binascii.hexlify(msg) + b&#x27;\\n&#x27;)    def set_key(self, rec):        if self.mac == int(rec[8:]):            self.r = self.counter    def guess_num(self, rec):        num = random.randint(0, 2**128)        if num == int(rec[10:]):            self.send(b&#x27;right&#x27;)            self.score += 1        else:            self.send(b&#x27;wrong&#x27;)    def get_flag(self, rec):        assert self.r != -1        if self.score ==  5:            self.send(flag, enc=False)        else:            self.send(os.urandom(32) +  flag)    def handle(self):        self.r = -1        if not self.POW():            self.send(b&#x27;Error Hash!&#x27;, enc= False)            return        self.n, self.hint, self.c ,self.counter, self.key, self.mac, self.score = init()        self.send(str(self.n).encode(), enc = False)        self.send(str(self.hint).encode(), enc = False)        self.send(str(self.c).encode(), enc = False)        for _ in range(6):            rec = self.recv()            if rec[:8] == b&#x27;set key:&#x27;:                self.set_key(rec)            elif rec[:10] == b&#x27;guess num:&#x27;:                self.guess_num(rec)            elif rec[:8] == b&#x27;get flag&#x27;:                self.get_flag(rec)            else:                self.send(b&#x27;something wrong, check your input&#x27;)class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passdef main():    HOST, PORT = &#x27;127.0.0.1&#x27;, 10086    server = ForkedServer((HOST, PORT), task)    server.allow_reuse_address = True    server.serve_forever()if __name__ == &#x27;__main__&#x27;:    main()\n这是一道经典的nc连接题，用了套接字模块，重点函数是handle()\ndef handle(self):    self.r = -1    if not self.POW():        self.send(b&#x27;Error Hash!&#x27;, enc= False)        return    self.n, self.hint, self.c ,self.counter, self.key, self.mac, self.score = init()    self.send(str(self.n).encode(), enc = False)    self.send(str(self.hint).encode(), enc = False)    self.send(str(self.c).encode(), enc = False)    for _ in range(6):        rec = self.recv()        if rec[:8] == b&#x27;set key:&#x27;:            self.set_key(rec)        elif rec[:10] == b&#x27;guess num:&#x27;:            self.guess_num(rec)        elif rec[:8] == b&#x27;get flag&#x27;:            self.get_flag(rec)        else:            self.send(b&#x27;something wrong, check your input&#x27;)\n先进行POW函数验证，就是判断hash值，爆破就行(就是去爆破下图的XXXX)按照RSA加密的方式给出了n，c和hint(服务端这几个值都是十六进制，要先转十进制)，且加密的明文是mac，先求它:所以mac&#x3D;gmpy2.iroot(pow(c,hint,n),2)[0];需要知道mac作用再来看到之后提供三种选择，set key，guess num，get flag\ndef set_key(self, rec):    if self.mac == int(rec[8:]):        self.r = self.counter\n似乎是判定输入的内容是否和mac一致，若一致，则进行一个赋值操作，看到是将counter赋值给r寻找counter的生成:\ndef init():    ...    counter = random.randint(0, 2**128)\n就是一个随机数，而self.r的初始值为-1由encrypt()函数可以看到\ndef encrypt(self, msg):    msg = self.padding(msg)    if self.r != -1:        self.r += 1        aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))        return aes.encrypt(msg)    else:        return msg\n如果self.r的值没有改变的话，也就是说没有进行set key操作的话，AES_CRT加密过程就不会生效；加密不生效就可以直接拿flag吗，再来看到get flag操作\ndef get_flag(self, rec):    assert self.r != -1    if self.score ==  5:        self.send(flag, enc=False)    else:        self.send(os.urandom(32) +  flag)\n有个assert self.r !&#x3D; -1，意味着必须self.r被随机生成的counter赋值才能进行get flag，否则会直接assert报错\n三种选择中还剩下一个guess num操作\ndef guess_num(self, rec):    num = random.randint(0, 2**128)    if num == int(rec[10:]):        self.send(b&#x27;right&#x27;)        self.score += 1    else:        self.send(b&#x27;wrong&#x27;)\n如果猜对随即生成的数字，则使得self.score +&#x3D; 1，而self.score的作用是在get flag中\nif self.score ==  5:    self.send(flag, enc=False)\n意味着连续猜中5次则能使得get flag操作直接返回flag\n但是细看一下，首先随机数生成的范围很大，不可能爆破；只能猜测一次，否则会在6次选择中浪费一次机会；最重要的是，6次选择中有一次机会必须用来set key（否则无法进行get flag操作），有一次机会用来get flag，只剩下4次机会，而我们需要连续猜中5次随机数；所以guess num操作在现在看来就是一个幌子\n那么要获得flag只能从encrypt函数下手这是一个CTR加密计数器CTR就是可以生成随机的初始值IV，而后每次加密序号都有递增生成过程:\nfrom Crypto.Util import Counter aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))\n看得出来是Counter.new(128, initial_value&#x3D;self.r))中initial_value变量在设置CTR的初始值\n而CTR所表示的值也不是简单的00，01，而是一组由随机数nonce和分组序号组成的初始值每加密一个明文分组，CTR的分组序号则会+1，使得进行加密操作之后的加密流与之前的加密流完全不同，达到与各个明文分组进行异或的字节串互不相同注:加密操作是指CTR生成后马上进行加密器的操作\n\n解密过程可以发现就是重置计数器CTR使其在对应的密文分组上产生与加密时一样的CTR，再将其进行加密操作，生成与加密过程中一样的加密流，与密文分组异或即得到明文分组我们发现加解密其实就两大块，CTR加密和异或；\n\n再回到题目脚本，这里容易发现，在每次服务器脚本send的时候，函数中很多地方都是send(x,enc &#x3D; False)，可以找到脚本中自己定义的send函数\n\n\n\ndef send(self, msg, enc=True):    print(msg, end= &#x27;   &#x27;)    if enc:        msg = self.encrypt(msg)    print(msg, self.r)    self.request.sendall(binascii.hexlify(msg) + b&#x27;\\n&#x27;)\n作用就是写出enc &#x3D; False的send函数里面，会直接输出内容，也就是正常交互过程中的send函数；而当enc &#x3D; True，或者说send函数里面没有对enc进行再赋值，那么输出的内容会进行encrypt()加密，也就是AES_CTR加密仔细观察可以发现:\nself.send(b&#x27;something wrong, check your input&#x27;)if num == int(rec[10:]):    self.send(b&#x27;right&#x27;)    self.score += 1else:    self.send(b&#x27;wrong&#x27;)\n这里的send函数返回的实际上不是明文right，something wrong…；而是AES_CTR加密后的密文（也可以在本地测试debug的时候发现这个特征）\n不可能无缘无故地把这些返回内容设置为加密之后再返回，所以这里一定是突破点\n现在我们可以得到一对明密文，AES_CTR加密后的flag；加密密钥key未知也无法知道，显然不能通过正常求密钥key来解密\n总共给予了6次选择的机会，那如果我们多得到几组明密文，有什么用呢\n在AES_CTR加密中，如果我们已知明文以及对应的密文，将两者异或即可得到加密流，因为加密过程中而加密流是由不同的CTR生成的，如果我们多收集一些加密流拼接在一起，再用来和加密后的flag进行异或，不就模拟了AES_CTR模式的解密过程吗\n那么最终的问题就是我们需要哪些加密流，也就是说哪些加密流是加密flag的时候真正使用的\n加密流当然是越长越好，所以我们使用something wrong…作为明密文组求得加密流，默认经过padding函数后明文长度为48\n正常情况下（本题不是这样的正常情况，之后会提到，也是关键点之一）是得到的加密流应该是由CTR，CTR+1，CTR+2生成的，那么很可能不够长足以使得与加密之后的flag异或可以得到完整的flag（因为flag加密过程中是作为padding(os.urandom(32)+flag)进行加密的，所以密文会比较长）\n那么现在有一个疑惑就是如果连续加密两次及以上的话，counter会不会自动继续+1，使得我们确实可以将对不同的加密过程（虽然明文确实是相同的）中生成的多个加密流按照CTR+i的顺序拼接在一起，作为一整个加密流\n&gt;&gt;&gt; from Crypto.Cipher import AES&gt;&gt;&gt; from Crypto.Util import Counter&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; key = b&#x27;\\x01&#x27; * 16&gt;&gt;&gt; msg = b&quot;flag1111111111111111111111111111111111111111111111111111111&quot;&gt;&gt;&gt; t = Counter.new(128, initial_value=123)&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)&gt;&gt;&gt; enc1 = aes.encrypt(msg)&gt;&gt;&gt; enc1b&quot;0=J\\xe6\\x87\\xec\\x07r\\xf1&#123;L\\x94\\xf7\\xf2\\xfcp|-\\xf0\\xca\\xba\\xe4:\\x89\\x7f\\rI\\xb5\\x84\\xb8\\x00\\xe2%(\\x02o\\xa5\\x8c\\xa3\\x93\\x18&#x27;\\xb0\\xa2\\xe2\\xd4]\\xb1*\\xb5\\x8fH7\\xd8\\xfa\\x8f\\x08\\xe7X&quot;&gt;&gt;&gt; enc2 = aes.encrypt(msg)&gt;&gt;&gt; enc2b&#x27;\\x97\\xf5\\xe3_\\xdc\\xb3\\x1c\\x11\\x1fM\\n\\x16\\x06&#125;:hvU\\x1d\\x93&quot;\\xf6\\x89\\xc3\\x05\\x94\\x8b&gt;6ha\\xce\\&#x27;\\x9f\\xb5$\\x07Hm\\xa5\\xd1]y)P\\xff\\xd3e\\xea\\x7f\\xa9\\xb3\\xe9\\xcd\\x88\\x97&gt;\\x8d\\xad&#x27;\n实践证明确实可以将不同加密过程中得到的加密流拼接在一起，但是如何确保对flag加密的加密流和我们求得的加密流一致呢，那就是重复使用set key操作\n大致重演一下重复使用set key的作用\n&gt;&gt;&gt; from Crypto.Cipher import AES&gt;&gt;&gt; from Crypto.Util import Counter&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; key = b&#x27;\\x01&#x27; * 16&gt;&gt;&gt; msg = b&quot;flag1111111111111111111111111111111111111111111111111111111&quot;&gt;&gt;&gt; t = Counter.new(128, initial_value=123)&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)&gt;&gt;&gt; enc1 = aes.encrypt(msg)&gt;&gt;&gt; enc2 = aes.encrypt(msg)&gt;&gt;&gt; t = Counter.new(128, initial_value=123)&gt;&gt;&gt; aes = AES.new(key, AES.MODE_CTR, counter = t)&gt;&gt;&gt; enc3 = aes.encrypt(msg)&gt;&gt;&gt; enc4 = aes.encrypt(msg)&gt;&gt;&gt; assert xor(enc1,msg) == xor(enc3,msg)&gt;&gt;&gt; assert xor(enc2,msg) == xor(enc4,msg)&gt;&gt;&gt;\n意思就是当我们重复对counter进行赋相同的值时，整个CTR初始值会被刷新\n那么我们是不是只需要两到三个something wrong…明密文对得到的加密流拼接在一起与flag进行异或就好了呢\n实践发现只能得到一半的flag，刚好就是前48位的padding(os.urandom(32)+flag)；之后的加密流为什么不是正确对应的呢\n发现作者在self.r和aes上面动了手脚，在每次加密整个明文之前self.r会自己首先+1，也就是CTR + 1；并且在每次加密整个明文之前都会重新定义一遍 aes &#x3D; AES.new(self.key, AES.MODE_CTR, counter &#x3D; Counter.new(128, initial_value&#x3D;self.r))，这就意味着对两次明文（不是明文分组）加密中所使用两个的CTR生成的加密流中，上一个明文的最后一组明文分组使用的是CTR + i，下一个明文的第一组明文分组的不是CTR + i + 1\ndef encrypt(self, msg):    msg = self.padding(msg)    if self.r != -1:        self.r += 1        aes = AES.new(self.key, AES.MODE_CTR, counter = Counter.new(128, initial_value=self.r))        return aes.encrypt(msg)    else:        return msg\n所以加密过程中的加密流实际上是CTR + 1，CTR + 2，CTR + 3等等通过加密操作生成的\n并且上一个明文（不是明文分组）加密所涉及的CTR初始值是CTR + 1，下一个明文加密所涉及的CTR初始值是CTR + 2（因为每次加密整个明文之前self.r +&#x3D; 1）\n所以其中mi是somgthing srong…的明文，意思是该明文在前后的加密过程中所使用的加密流是由以上CTR + i生成的\n为了使得flag使用的是已知的加密流，我们使用set key操作把CTR刷新，使得那么对mi进行对应的截取即可\nfrom pwn import *from Crypto.Util.number import *import gmpy2import hashlibimport stringimport randomimport binasciicontext.log_level=&#x27;debug&#x27;io = remote(&quot;192.168.109.129&quot;,&quot;9998&quot;)io.recvuntil(b&quot;+&quot;)tmp = io.recvuntil(b&quot;\\n&quot;)part_proof = tmp.split(b&quot;) == &quot;)[0]result = tmp.split(b&quot;) == &quot;)[1][:-1]table = string.ascii_letters + string.digitswhile True:    XXXX = (&quot;&quot;.join(random.sample(table,4))).encode()    if hashlib.sha256(XXXX + part_proof).hexdigest() == result.decode():        io.recvuntil(b&quot;\\n&quot;)        io.sendline(XXXX)        breakn = int(binascii.unhexlify(io.recvline()[:-1]))hint = int(binascii.unhexlify(io.recvline()[:-1]))c =  int(binascii.unhexlify(io.recvline()[:-1]))mac = gmpy2.iroot(pow(c,hint,n) % n,2)[0]io.sendline(b&quot;set key:&quot; + str(mac).encode())enc = []for _ in range(3):    io.sendline(b&quot;I_want_flag&quot;)    time.sleep(0.5)    tmp = io.recvline()[:-1].decode()    if _ != 2:        enc.append(long_to_bytes(int(str(tmp),16))[:16])    else:        enc.append(long_to_bytes(int(str(tmp),16)))# print(enc)io.sendline(b&quot;set key:&quot; + str(mac).encode())time.sleep(0.5)io.sendline(b&quot;get flag&quot;)time.sleep(0.5)tmp = io.recvline()enc_flag = binascii.unhexlify(tmp[:-1])msg = b&#x27;something wrong, check your input&#x27;msg = msg + chr((16 - len(msg)%16)).encode() * (16 - len(msg)%16)key_stream = b&quot;&quot;for i in enc:    key_stream += xor(i,msg[:len(i)]) print(xor(enc_flag,key_stream[:len(enc_flag)]))\n关于AES的深入一点的题目都是交互式的，正常情况不会要求求密钥key，而是利用xor的特性以及加密器（相当于黑盒加密）来从服务器脚本处骗取可以求得flag的数值\n关于交互式的题目没有头绪的时候更倾向于直接与服务端进行交互查看debug返回，而不单是查看服务器所使用的脚本\nCrypto的交互式题目需要注意服务端返回的内容是什么类型的，很可能脚本会对十进制数值转字节再转十六进制，可能要进行一定的数据处理\n"},{"title":"AES","url":"/2025/01/16/AES/","content":"简介高级加密标准(AES)是最常见的对称加密算法，即加密和解密都用相同的密钥AES的解密函数为D，P&#x3D;D(K,C)其中C为密文，K为密钥，P为明文。实际上一般是通过RSA加密密钥，传给接收方，接收方再解密得到AES密钥，然后两方通过密钥来通信。\n基本结构AES是分组密码，是将明文分为一组一组进行加密，每组长度相同，直到加密完整组明文，在AES中，分组长度只能是128位，也就是说，每组长度16个字节，而密钥可以是128位，192位，256位，密钥长度不同，推荐加密轮数也不同轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C &#x3D; E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次(没有列混合)有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。\nAES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P &#x3D; P0 P1 … P15 和 K &#x3D; K0 K1 … K15。如，明文分组为P &#x3D; abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：我们也可以将矩阵的每一列作为一个元素，每一列被称为1个32位比特字，被扩展成一个44字组成的序列W[0],W[1]…,前四个元素W[0],W[1],W[2],W[3]是原始密钥AES的整体结构如下，加密操作包括：字节代换，行位移，列混合和轮密钥加，最后一轮迭代不执行列混合，另外在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作AES的四个操作都可逆，下面介绍四个操作:\n1.字节代换AES字节代换就是一个查表操作，定义了一个S盒和逆S盒S盒：在输出字节时，把该字节的高4位作为行值，低4位作为列值(先将字节化为二进制，前面四个数字为高4位，后面为低4位，0x12&#x3D;0001 0010，所以行为1，列为2)取出S盒或逆S盒作为输出，例如输出字节为S1为0x12，则查S盒的0x01行和0x02列，得到0xc9，然后替换S1原有的0x12为0xc9，如下：\n字节代换逆操作逆字节代换就是查逆S盒：\n\n\n\n行&#x2F;列\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nA\nB\nC\nD\nE\nF\n\n\n\n0\n0x52\n0x09\n0x6a\n0xd5\n0x30\n0x36\n0xa5\n0x38\n0xbf\n0x40\n0xa3\n0x9e\n0x81\n0xf3\n0xd7\n0xfb\n\n\n1\n0x7c\n0xe3\n0x39\n0x82\n0x9b\n0x2f\n0xff\n0x87\n0x34\n0x8e\n0x43\n0x44\n0xc4\n0xde\n0xe9\n0xcb\n\n\n2\n0x54\n0x7b\n0x94\n0x32\n0xa6\n0xc2\n0x23\n0x3d\n0xee\n0x4c\n0x95\n0x0b\n0x42\n0xfa\n0xc3\n0x4e\n\n\n3\n0x08\n0x2e\n0xa1\n0x66\n0x28\n0xd9\n0x24\n0xb2\n0x76\n0x5b\n0xa2\n0x49\n0x6d\n0x8b\n0xd1\n0x25\n\n\n4\n0x72\n0xf8\n0xf6\n0x64\n0x86\n0x68\n0x98\n0x16\n0xd4\n0xa4\n0x5c\n0xcc\n0x5d\n0x65\n0xb6\n0x92\n\n\n5\n0x6c\n0x70\n0x48\n0x50\n0xfd\n0xed\n0xb9\n0xda\n0x5e\n0x15\n0x46\n0x57\n0xa7\n0x8d\n0x9d\n0x84\n\n\n6\n0x90\n0xd8\n0xab\n0x00\n0x8c\n0xbc\n0xd3\n0x0a\n0xf7\n0xe4\n0x58\n0x05\n0xb8\n0xb3\n0x45\n0x06\n\n\n7\n0xd0\n0x2c\n0x1e\n0x8f\n0xca\n0x3f\n0x0f\n0x02\n0xc1\n0xaf\n0xbd\n0x03\n0x01\n0x13\n0x8a\n0x6b\n\n\n8\n0x3a\n0x91\n0x11\n0x41\n0x4f\n0x67\n0xdc\n0xea\n0x97\n0xf2\n0xcf\n0xce\n0xf0\n0xb4\n0xe6\n0x73\n\n\n9\n0x96\n0xac\n0x74\n0x22\n0xe7\n0xad\n0x35\n0x85\n0xe2\n0xf9\n0x37\n0xe8\n0x1c\n0x75\n0xdf\n0x6e\n\n\nA\n0x47\n0xf1\n0x1a\n0x71\n0x1d\n0x29\n0xc5\n0x89\n0x6f\n0xb7\n0x62\n0x0e\n0xaa\n0x18\n0xbe\n0x1b\n\n\nB\n0xfc\n0x56\n0x3e\n0x4b\n0xc6\n0xd2\n0x79\n0x20\n0x9a\n0xdb\n0xc0\n0xfe\n0x78\n0xcd\n0x5a\n0xf4\n\n\nC\n0x1f\n0xdd\n0xa8\n0x33\n0x88\n0x07\n0xc7\n0x31\n0xb1\n0x12\n0x10\n0x59\n0x27\n0x80\n0xec\n0x5f\n\n\nD\n0x60\n0x51\n0x7f\n0xa9\n0x19\n0xb5\n0x4a\n0x0d\n0x2d\n0xe5\n0x7a\n0x9f\n0x93\n0xc9\n0x9c\n0xef\n\n\nE\n0xa0\n0xe0\n0x3b\n0x4d\n0xae\n0x2a\n0xf5\n0xb0\n0xc8\n0xeb\n0xbb\n0x3c\n0x83\n0x53\n0x99\n0x61\n\n\nF\n0x17\n0x2b\n0x04\n0x7e\n0xba\n0x77\n0xd6\n0x26\n0xe1\n0x69\n0x14\n0x63\n0x55\n0x21\n0x0c\n0x7d\n\n\n2.行位移行位移是一个简单的左循环移位操作，当密钥长度为128比特时，第0行左移0字节，第1行左移1字节，以此类推:\n行位移的逆变换行位移的逆变换是将状态矩阵中的每一行执行相反的移位操作，即左移变右移。\n3.列混合1.列混合操作列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图公式：状态矩阵的第j列的列混合可以表示为：其中，矩阵元素的乘法和加法都是定义于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 &#x3D; (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：也就是说如果a7为1，进行异或运算，否则不进行。类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算:乘以(00000011)可以拆分成先分别乘以(0000 0001)和(0000 0010)再将两个乘积异或:所以，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现下面举个具体的例子，输入的状态矩阵如下:然后进行列混合计算:得到新矩阵为:\n2.列混合逆运算逆向列混合计算,也是和一个固定矩阵相乘:逆变换矩阵同正变换矩阵相乘就是单位矩阵\n4.轮密钥加轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示，其中密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法会放在下面，轮密钥加可以看作是字逐位异或的结果，也可以看成字节级别或者位级别的操作，也就是说，可以看成S0,S1,S2,S3组成的32位字与W[4i]的异或运算。轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能影响S数组中的每一位\n密钥扩展AES首先将初始密钥输入到一个4*4的矩阵中：这个矩阵的每一列的4个字节组成一个字，矩阵4列的4个字一次命名为W[0],W[1],W[2].W[3],它们构成了一个以字为单位的数组W。比如，K&#x3D;abcdefghijklmnop，K0&#x3D;a,K1&#x3D;b,K2&#x3D;c,K3&#x3D;d,W[0]&#x3D;abcd接着对W数组进行扩充，扩充40个新列，新列以递归方式产生:1.如果i不是4的倍数，那么第i列由如下等式确定：W[i]&#x3D;W[i-4]⨁W[i-1]2.如果i是4的倍数，那么第i列由如下等式确定：W[i]&#x3D;W[i-4]⨁T(W[i-1])其中，T是一个有点复杂的函数。其中，T是一个有点复杂的函数。函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。b.字节代换：对字循环的结果使用S盒进行字节代换。c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。轮常量Rcon[j]是一个字，其值见下表。下面举个例子：设初始的128位密钥为：3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD那么4个初始值为：W[0] &#x3D; 3C A1 0B 21W[1] &#x3D; 57 F0 19 16W[2] &#x3D; 90 2E 13 80W[3] &#x3D; AC C1 07 BD下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。由于4是4的倍数，所以：W[4] &#x3D; W[0] ⨁ T(W[3])T(W[3])的计算步骤如下：\n1.循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;\n2.将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;\n3.将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])&#x3D;79 C5 7A 91，故W[4] &#x3D; 3C A1 0B 21 ⨁ 79 C5 7A 91 &#x3D; 45 64 71 B0其余的3个子密钥段的计算如下：W[5] &#x3D; W[1] ⨁ W[4] &#x3D; 57 F0 19 16 ⨁ 45 64 71 B0 &#x3D; 12 94 68 A6W[6] &#x3D; W[2] ⨁ W[5] &#x3D;90 2E 13 80 ⨁ 12 94 68 A6 &#x3D; 82 BA 7B 26W[7] &#x3D; W[3] ⨁ W[6] &#x3D; AC C1 07 BD ⨁ 82 BA 7B 26 &#x3D; 2E 7B 7C 9B所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。\nAES解密具体就是通过将加密流程中的步骤由正变换变为逆变换\nAES加密代码实现:\nimport base64from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytessecret = &quot;123456789123456789123456789123&quot;             #由用户输入的16位或24位或32位长的初始密码字符串print(&#x27;密钥长度：&#x27;,len(secret))#密钥处理,16的整数倍def add_to_16(text):    while len(text)%16 !=0:        text+=&#x27;\\0&#x27;    return (text)secret=add_to_16(secret)print(&#x27;不做任何填充，但是要求密钥必须是16字节的整数倍:&#x27;,secret)#cipher = AES.new(secret.encode(&#x27;utf-8&#x27;),AES.MODE_ECB)      #通过AES.MODE_ECB处理初始密码字符串，并返回cipher对象iv=get_random_bytes(16)  #随机获取16位变量cipher = AES.new(secret.encode(&#x27;utf-8&#x27;),AES.MODE_CBC,iv)data=&quot;flag&#123;I_love_CS2&#125;&quot;#明文处理def add_to_16(text):    while len(text)%16 !=0:        text+=&#x27;\\0&#x27;    return (text)data=add_to_16(data)print(&#x27;明文：&#x27;,data)encrypt_data= cipher.encrypt(data.encode(&#x27;utf-8&#x27;))     #输入需要加密的字符串，注意字符串长度要是16的倍数。16,32,48..print (&#x27;密文&#x27;,encrypt_data)                                              #输出加密后的字符串encrypt_data = base64.b64encode(encrypt_data)print (&#x27;密文的base64编码:&#x27;,base64.b64encode(encrypt_data))             #输出加密后的字符串的base64编码。encrypt_data = base64.b64decode(encrypt_data)print(&#x27;密文的base64编码的解码:&#x27;,encrypt_data)cipher = AES.new(secret.encode(&#x27;utf-8&#x27;),AES.MODE_CBC,iv)decrypt_data = cipher.decrypt(encrypt_data)decrypt_data=decrypt_data.decode(&#x27;utf-8&#x27;)print(&#x27;明文:&#x27;,decrypt_data)"},{"title":"LFSR","url":"/2025/01/05/LFSR/","content":"LFSR概念了解LFSR是指线性反馈移位寄存器，给定一定的输出，将该输出的线性代数再用作输入的移位寄存器，异或运算是最常见的单比特线性代数：对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分联合使用.\n原理LFSR是FSR的一种，还有一种是NFSR(非线性)函数可表示为:\n\n这里给不了解布尔运算的做一个基础补充：布尔运算分为与运算，或运算，异或运算和非运算\n与运算：\n或运算\n异或运算\n非运算\n\n\nan+1&#x3D;c1an⊕c2an-1⊕…⊕cna1\nan+2&#x3D;c1an+1⊕c2an⊕…⊕cna2\n…\nan+i&#x3D;c1an+i-1⊕c2an+i-2⊕…⊕cnai(i&#x3D;1,2,3…)\n\n例如:题型:1.已知反馈函数，输出序列，求逆推出初始状态\nfrom flag import flagassert flag.startswith(&quot;flag&#123;&quot;)assert flag.endswith(&quot;&#125;&quot;)# 作用：判断字符串是否以指定字符 开头或结尾assert len(flag)==25def lfsr(R,mask):    output = (R &lt;&lt; 1) &amp; 0xffffff #将R向左移动1位，bin(0xffffff)=&#x27;0b111111111111111111111111&#x27;    i=(R&amp;mask)&amp;0xffffff          #按位与运算符&amp;：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0    lastbit=0    while i!=0:        lastbit^=(i&amp;1)           #按位异或运算，得到输出序列        i=i&gt;&gt;1    output^=lastbit              #将输出值写入 output的后面    return (output,lastbit)R=int(flag[5:-1],2)  #flag为二进制数据mask    =   0b1010011000100011100f=open(&quot;key&quot;,&quot;ab&quot;)   #以二进制追加模式打开for i in range(12):    tmp=0    for j in range(8):        (R,out)=lfsr(R,mask)        tmp=(tmp &lt;&lt; 1)^out    f.write(chr(tmp))   #将lfsr输出的序列每8个二进制为一组，转化为字符，共12组f.close()\n思路:第一种方法:\nfrom Crypto.Util.number import*f = open(&#x27;key.txt&#x27;,&#x27;rb&#x27;).read()r = bytes_to_long(f)bin_out = bin(r)[2:].zfill(12*8)R = bin_out[:19]    #获取输出序列中与掩码msk长度相同的值print(R)mask = &#x27;1010011000100011100&#x27;  #顺序 c_n,c_n-1,。。。,c_1key =  &#x27;0101010100111000111&#x27;R = &#x27;&#x27;for i in range(19):    output = &#x27;x&#x27;+key[:18]    out = int(key[-1])^int(output[-3])^int(output[-4])^int(output[-5])^int(output[-9])^int(output[-13])^int(output[-14])^int(output[-17])    R += str(out)    key = str(out)+key[:18]print(&#x27;flag&#123;&#x27;+R[::-1]+&#x27;&#125;&#x27;)\n第二种方法：猜seed\nfrom Crypto.Util.number import*import os,sysos.chdir(sys.path[0])f = open(&#x27;key.txt&#x27;,&#x27;rb&#x27;).read()c = bytes_to_long(f)bin_out = bin(c)[2:].zfill(12*8)   #将key文本内容转换为 2 进制数，每个字节占 8 位R = bin_out[0:19]  #取输出序列的前19位mask = 0b1010011000100011100def lfsr(R,mask):    output = (R &lt;&lt; 1) &amp; 0xffffffff    i=(R&amp;mask)&amp;0xffffffff    lastbit=0    while i!=0:        lastbit^=(i&amp;1)        i=i&gt;&gt;1    output^=lastbit    return (output,lastbit)#根据生成规则，初始状态最后一位拼接输出序列#我们可以猜测seed的第19位（0或1），如果seed19+R[:18]输出值等于R[:19]，那么就可以确定seed值了def decry():    cur = bin_out[0:19]      #前19位 2 进制数    res = &#x27;&#x27;    for i in range(19):        if lfsr(int(&#x27;0&#x27;+cur[0:18],2),mask)[0] == int(cur,2):            res += &#x27;0&#x27;            cur = &#x27;0&#x27;+cur[0:18]        else:            res += &#x27;1&#x27;            cur = &#x27;1&#x27; + cur[0:18]    return int(res[::-1],2)r = decry()print(bin(r))\n第三种方法:\nimport os,sysos.chdir(sys.path[0])from Crypto.Util.number import *key = &#x27;0101010100111000111&#x27;mask = 0b1010011000100011100R = &quot;&quot;index = 0key = key[18] + key[:19]while index &lt; 19:    tmp = 0    for i in range(19):        if mask &gt;&gt; i &amp; 1:            tmp ^= int(key[18 - i])    R += str(tmp)    index += 1    key = key[18] + str(tmp) + key[1:18]print (R[::-1])\n"},{"title":"Coppersmith攻击","url":"/2025/01/23/Coppersmith%E6%94%BB%E5%87%BB/","content":"Coppersmith攻击coppersmith是一种针对于模多项式找所有小整数根的攻击方式，有单变量，二元变量和多元变量三种形式，它运用LLL算法来实现我的理解的是我们可以根据已知的公钥，密文和部分明文来构造一个多项式,然后用LLL算法将多项式转化为格的形式，通过寻找短向量来解出多项式的根，根的值就可能是私钥d或者明文。具体可以参考ctf-wiki(https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_coppersmith_attack/)\nSUCTF:ez_RSA\nfrom Crypto.Util.number import *from hashlib import sha256flag = open(&quot;flag.txt&quot;).read()p = getPrime(512)q = getPrime(512)e = getPrime(256)n = p*qd = inverse(e,(p-1)*(q-1))d_m = ((d &gt;&gt; 512) &lt;&lt; 512)print(&quot;d_m = &quot;,d_m)print(&quot;n = &quot;,n)print(&quot;e = &quot;,e)assert flag[6:-1] == sha256(str(p).encode()).hexdigest()[:32]# d_m =  54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128# n =  102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623# e =  112238903025225752449505695131644979150784442753977451850362059850426421356123\n这里给的是d的高位由n&#x3D;pq和φn&#x3D;(p-1)(q-1)得到φn&#x3D;n-p-q+1代入de&#x3D;kφn+1这边是一个近似推导dme约等于k*(n-p-q+1)+1,由于n-p-q+1中n是1024位的素数，p和q的和对n的影响有限，可以简化为n所以可得下面关系$$k&#x3D;(ed_m-1)&#x2F;&#x2F;n + 1$$由标准关系得到$$k(n-p-q+1)+1&#x3D;&#x3D;e*d\\(p+q) &#x3D;(n+1+k^{-1})\\mod e$$那么可以通过coppersmith方法来构造多项式寻找根，从而解出p和q\nfrom sage.all import *def small_roots(f, X, beta=1.0, m=None):    N = f.parent().characteristic()    delta = f.degree()    if m is None:        epsilon = RR(beta**2 / f.degree() - log(2 * X, N))        m = max(beta**2 / (delta * epsilon), 7 * beta / delta).ceil()    t = int((delta * m * (1 / beta - 1)).floor())    f = f.monic().change_ring(ZZ) #单项式化    P, (x,) = f.parent().objgens()    g = [x**j * N**(m - i) * f**i for i in range(m) for j in range(delta)]    g.extend([x**i * f**m for i in range(t)])    # 直接使用 Sage 的方法来处理矩阵 B    B = Matrix(ZZ, len(g), delta * m + max(delta, t))    for i in range(B.nrows()):        for j in range(g[i].degree() + 1):            B[i, j] = g[i][j] * X**j    # 计算 B 的行简化形式    B = B.echelon_form()  # 替代 flatter    f = sum([ZZ(B[0, i] // X**i) * x**i for i in range(B.ncols())])        roots = set([f.base_ring()(r) for r, m in f.roots() if abs(r) &lt;= X])    return [root for root in roots if N.gcd(ZZ(f(root))) &gt;= N**beta]d_m =  54846367460362174332079522877510670032871200032162046677317492493462931044216323394426650814743565762481796045534803612751698364585822047676578654787832771646295054609274740117061370718708622855577527177104905114099420613343527343145928755498638387667064228376160623881856439218281811203793522182599504560128n =  102371500687797342407596664857291734254917985018214775746292433509077140372871717687125679767929573899320192533126974567980143105445007878861163511159294802350697707435107548927953839625147773016776671583898492755338444338394630801056367836711191009369960379855825277626760709076218114602209903833128735441623e =  112238903025225752449505695131644979150784442753977451850362059850426421356123# 计算 k 和 sk = (e * d_m - 1) // n + 1s = (n + 1 + inverse_mod(k, e)) % e# 构造多项式PR.&lt;x&gt; = PolynomialRing(Zmod(e))f = x^2 - s * x + np0 = int(f.roots()[0][0])# 查找小根PR.&lt;x0&gt; = PolynomialRing(Zmod(n))for i in range(0, 2**6):    f = e * (x0 + 2**250 * i) + p0    root = small_roots(f, X=2**250, beta=0.48, m=25)    print(&quot;Roots found:&quot;, root)x0 = 769306974883685623850311905036778346829296744303179040979107875413852719182p = e * (x0 + 2**250 * 44) + p0q = n // pprint(&quot;p:&quot;, p)print(&quot;q:&quot;, q)\n\n"},{"title":"LLL算法和Coppersmith","url":"/2025/01/23/LLL%E7%AE%97%E6%B3%95%E5%92%8CCoppersmith/","content":""}]